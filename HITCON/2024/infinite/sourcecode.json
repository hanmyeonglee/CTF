{
  "success": true,
  "source": {
    "team.py": "import httpx\n\nfrom .config import config\n\nscoreboard_base_url = config[\"scoreboard\"][\"scoreboard_uri\"].rstrip(\"/\")\n\n__token2team_id_cache = None\nasync def token2team_id(token: str) -> int | None:\n    global __token2team_id_cache\n\n    # for local testing\n    if not config[\"scoreboard\"][\"use_scoreboard_to_auth_team\"]:\n        if __token2team_id_cache is None:\n            __token2team_id_cache = {team['token']: team['team_id'] for team in config['teams']}\n\n        return __token2team_id_cache.get(token)\n\n    # for production\n    if __token2team_id_cache is None:\n        __token2team_id_cache = {}\n\n    if token in __token2team_id_cache:\n        return __token2team_id_cache[token]\n\n    async with httpx.AsyncClient() as client:\n        resp = await client.get(f\"{scoreboard_base_url}/team/my\", headers={\"Authorization\": token})\n        if resp.status_code == 200:\n            team_id = resp.json()[\"id\"]\n            __token2team_id_cache[token] = team_id\n            return team_id\n        else:\n            return None\n",
    "ratelimit.py": "from fastapi.responses import JSONResponse\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.routing import Match, Mount\nfrom limits import parse\nfrom limits.storage import storage_from_string\nfrom limits.aio.strategies import FixedWindowRateLimiter\n\nfrom .config import config\n\nredis = storage_from_string(config['rate_limit']['redis_uri'])\nmoving_window = FixedWindowRateLimiter(redis)\n\n\n# create a fastapi middleware\nclass RateLimitMiddleware(BaseHTTPMiddleware):\n    __limits = {}\n    default_limit = parse(config['rate_limit']['default'])\n\n    @staticmethod\n    def handler_name(handler):\n        return f'{handler.__module__}.{handler.__name__}'\n\n    @classmethod\n    def limit(cls, limit):\n        def decorator(handler):\n            cls.__limits[cls.handler_name(handler)] = parse(limit)\n            return handler\n        return decorator\n\n    async def dispatch(self, request, call_next):\n        if not config['rate_limit']['enabled']:\n            return await call_next(request)\n\n        app = request.app\n        for route in app.routes:\n            if isinstance(route, Mount):\n                continue\n\n            match_, _ = route.matches(request.scope)\n            if match_ == Match.FULL:\n                handler = route.endpoint\n                break\n        else:\n            return await call_next(request)\n\n        name = self.handler_name(handler)\n        limit = self.__limits.get(name, self.default_limit)\n\n        # use http path, method, and client ip as key\n        key = (request.url.path, request.method, request.client.host)\n\n        success = await moving_window.hit(limit, *key)\n        if not success:\n            return JSONResponse({'error': 'rate limit exceeded'}, status_code=429)\n\n        return await call_next(request)\n",
    "main.py": "from contextlib import asynccontextmanager\nimport logging\nfrom pathlib import Path\n\nfrom fastapi import FastAPI\nfrom fastapi.responses import FileResponse\nfrom fastapi.staticfiles import StaticFiles\n\nfrom .db import db\nfrom .ratelimit import RateLimitMiddleware\nfrom .route.craft import router as craft_router\nfrom .route.bounty import router as bounty_router\nfrom .config import config\nfrom .team import token2team_id\n\n\nlogging.getLogger(\"httpx\").setLevel(logging.WARNING)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await db.init()\n    try:\n        yield\n    finally:\n        return\n\n\napp = FastAPI(lifespan=lifespan)\napp.add_middleware(RateLimitMiddleware)\napp.include_router(craft_router)\napp.include_router(bounty_router)\napp.mount(\"/static\", StaticFiles(directory=\"frontend/static\"), name=\"static\")\n\n\n@app.get(\"/\")\nasync def homepage():\n    return FileResponse(\"frontend/index.html\")\n\n\n@app.get(\"/my_inventory\")\n@RateLimitMiddleware.limit(config[\"rate_limit\"][\"get_inventory\"])\nasync def get_inventory(team_token: str):\n    if (team_id := await token2team_id(team_token)) is None:\n        return {\"error\": \"invalid team token\"}\n\n    return await db.get_inventory(team_id)\n\n\n@app.get(\"/current_round\")\nasync def get_current_round() -> int | None:\n    return await db.get_current_round()\n\n\n@app.get(\"/round_info\")\nasync def get_round_info(round_id: int):\n    return await db.get_round_info(round_id)\n\n\n@app.get(\"/G1v3_m3_soUr5e_C0dE\")\n@RateLimitMiddleware.limit(config[\"rate_limit\"][\"get_source_code\"])\nasync def get_source_code(team_token: str):\n    if (team_id := await token2team_id(team_token)) is None:\n        return {\"error\": \"invalid team token\"}\n\n    unlocked_elements = [pair[0] for pair in await db.get_inventory(team_id)]\n    condition = config[\"get_source_code_condition\"]\n\n    if not all(elem in unlocked_elements for elem in condition):\n        return {\"success\": False, \"need\": condition}\n\n    source = {}\n    for file in Path(__file__).parent.glob(\"**/*.py\"):\n        if file.name == \"test.py\":\n            continue\n        with open(file) as f:\n            source[file.name] = f.read()\n    return {\"success\": True, \"source\": source}\n\n\n@app.get(\"/get_recipe\", include_in_schema=False)\n@RateLimitMiddleware.limit(config[\"rate_limit\"][\"get_recipe\"])\nasync def get_recipe(team_token: str, element: str):\n    if (team_id := await token2team_id(team_token)) is None:\n        return {\"error\": \"invalid team token\"}\n\n    try:\n        recipe = await db.get_recipe(team_id, element)\n    except Exception as e:\n        return {\"error\": str(e)}\n\n    result = []\n    for element in recipe:\n        element_id, english_name, *materials = element\n        result.append(\n            {\"id\": element_id, \"english_name\": english_name, \"materials\": materials}\n        )\n\n    return {\"success\": True, \"recipe\": result}\n\n\n# debugging endpoints\nif config[\"debug\"][\"enable_endpoint\"]:\n\n    @app.get(\"/debug\")\n    async def debug():\n        await db.debug()\n\n    @app.get(\"/debug_clear_bounty\")\n    async def debug_clear_bounty():\n        await db.debug_clear_bounty()\n\n    @app.get(\"/debug_clear_round\")\n    async def debug_clear_round():\n        await db.debug_clear_round()\n\n    @app.get(\"/debug_incr_round\")\n    async def debug_incr_round():\n        prev_round_id = await db.get_current_round()\n        await db.insert_round_and_set_prev_round_end()\n        from .round import RoundManager\n\n        async with RoundManager() as rm:\n            await rm.calculate_round_rank(prev_round_id)\n\n    @app.get(\"/debug_clear_recipe\")\n    async def debug_clear_recipe():\n        await db.debug_clear_recipe()\n",
    "db.py": "from datetime import datetime\n\nfrom mysql.connector.aio import connect\n\nfrom .model import Query, Bounty\nfrom .config import config\n\n\nclass DBConnection:\n    async def __aenter__(self):\n        self.cnx = await connect(\n            user=config[\"db\"][\"user\"],\n            password=config[\"db\"][\"password\"],\n            host=config[\"db\"][\"host\"],\n            database=config[\"db\"][\"database\"],\n            port=config[\"db\"][\"port\"],\n            autocommit=True,\n            buffered=True,\n        )\n        self.cursor = await self.cnx.cursor()\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await self.cursor.close()\n        await self.cnx.close()\n\n\nclass DB:\n    async def init(self):\n        await self.create_tables()\n\n    async def create_tables(self):\n        async with DBConnection() as cnx:\n            # create tables if not exists\n            await cnx.cursor.execute(\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS element (\n                    id INT AUTO_INCREMENT PRIMARY KEY,\n                    english_name VARCHAR(255) NOT NULL UNIQUE,\n                    symbol VARCHAR(255) NOT NULL\n                )\n                \"\"\"\n            )\n            await cnx.cursor.execute(\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS recipe (\n                    id INT AUTO_INCREMENT PRIMARY KEY,\n                    product_english_name VARCHAR(255) NOT NULL,\n                    material0 VARCHAR(255) NOT NULL,\n                    material1 VARCHAR(255) NOT NULL,\n                    material2 VARCHAR(255) NOT NULL,\n                    material3 VARCHAR(255) NOT NULL,\n                    material4 VARCHAR(255) NOT NULL,\n                    material5 VARCHAR(255) NOT NULL,\n                    material6 VARCHAR(255) NOT NULL,\n                    material7 VARCHAR(255) NOT NULL\n                )\n                \"\"\"\n            )\n            await cnx.cursor.execute(\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS team_element_unlocked (\n                    id INT AUTO_INCREMENT PRIMARY KEY,\n                    team_id INT NOT NULL,\n                    english_name VARCHAR(255) NOT NULL\n                )\n                \"\"\"\n            )\n            await cnx.cursor.execute(\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS bounty (\n                    id INT AUTO_INCREMENT PRIMARY KEY,\n                    team_id INT NOT NULL,\n                    target_product VARCHAR(255), /* NULL means the team cleared its bounty */\n                    length INT NOT NULL,\n                    bounty_body TEXT NOT NULL,\n                    is_submitted BOOLEAN DEFAULT TRUE,\n                    created_at TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6)\n                )\n                \"\"\"\n            )\n            await cnx.cursor.execute(\n                \"\"\"\n                CREATE TABLE IF NOT EXISTS round (\n                    id INT AUTO_INCREMENT PRIMARY KEY,\n                    round_id INT NOT NULL UNIQUE,\n                    end_at TIMESTAMP(6) DEFAULT NULL,\n                    round_rank TEXT DEFAULT NULL\n                )\n                \"\"\"\n            )\n\n            # placeholder round\n            await cnx.cursor.execute(\n                \"\"\"\n                INSERT INTO round (round_id) VALUES (0) ON DUPLICATE KEY UPDATE round_id = 0\n                \"\"\"\n            )\n\n        # insert initial data\n        for item in config[\"initial_items\"]:\n            # insert the item\n            await self.insert_item(\n                item[\"english_name\"],\n                item[\"symbol\"],\n                (\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"),\n            )\n\n            # unlock the item for all teams\n            for team in config[\"teams\"]:\n                await self.unlock_item(team[\"team_id\"], item[\"english_name\"])\n\n    async def unlock_item(self, team_id: int, english_name: str):\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                INSERT INTO team_element_unlocked (team_id, english_name)\n                SELECT %s, %s\n                WHERE NOT EXISTS (\n                    SELECT 1 FROM team_element_unlocked WHERE team_id = %s AND english_name = %s\n                )\n                \"\"\",\n                (team_id, english_name, team_id, english_name),\n            )\n\n    async def insert_item(\n        self,\n        english_name: str,\n        symbol: str,\n        materials: tuple[str, str, str, str, str, str, str, str],\n        team_id: int | None = None,\n    ):\n        materials = tuple(sorted(materials))\n\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                INSERT INTO recipe (product_english_name, material0, material1, material2, material3, material4, material5, material6, material7)\n                SELECT %s, %s, %s, %s, %s, %s, %s, %s, %s\n                WHERE NOT EXISTS (\n                    SELECT 1 FROM recipe WHERE product_english_name = %s AND material0 = %s AND material1 = %s AND material2 = %s AND material3 = %s AND material4 = %s AND material5 = %s AND material6 = %s AND material7 = %s\n                )\n                \"\"\",\n                (english_name, *materials, english_name, *materials),\n            )\n\n            await cnx.cursor.execute(\n                \"\"\"\n                INSERT INTO element (english_name, symbol)\n                SELECT %s, %s\n                WHERE NOT EXISTS (\n                    SELECT 1 FROM element WHERE english_name = %s\n                )\n                \"\"\",\n                (english_name, symbol, english_name),\n            )\n\n            if team_id is not None:\n                await self.unlock_item(team_id, english_name)\n\n    async def element_exist(self, english_name: str):\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT symbol FROM element WHERE english_name = %s\n                \"\"\",\n                (english_name,),\n            )\n            if len(row := await cnx.cursor.fetchall()) == 0:\n                return None\n            return row[0][0]\n\n    async def craft(self, query: Query):\n        team_id = await query.team_id()\n        materials = query.sorted_materials\n\n        async with DBConnection() as cnx:\n\n            # fast check: if recipe exists and is unlocked\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT recipe.product_english_name, element.symbol\n                FROM recipe\n                JOIN team_element_unlocked ON recipe.product_english_name = team_element_unlocked.english_name\n                JOIN element ON recipe.product_english_name = element.english_name\n                WHERE\n                    material0 = %s AND\n                    material1 = %s AND\n                    material2 = %s AND\n                    material3 = %s AND\n                    material4 = %s AND\n                    material5 = %s AND\n                    material6 = %s AND\n                    material7 = %s AND\n                    team_id = %s\n                LIMIT 1\n                \"\"\",\n                (*materials, team_id),\n            )\n\n            if len(row := await cnx.cursor.fetchall()) > 0:\n                return row[0]\n\n            # check if all materials are unlocked by the team\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT COUNT(*) FROM team_element_unlocked\n                WHERE team_id = %s AND (\n                    english_name = %s OR\n                    english_name = %s OR\n                    english_name = %s OR\n                    english_name = %s OR\n                    english_name = %s OR\n                    english_name = %s OR\n                    english_name = %s OR\n                    english_name = %s\n                )\n                LIMIT 1\n                \"\"\",\n                (team_id, *materials),\n            )\n\n            # check if the number of unlocked materials is equal to the number of unique materials\n            if len(row := await cnx.cursor.fetchall()) == 0 or row[0][0] != len(\n                set(materials)\n            ):\n                raise ValueError(\"Not all materials are unlocked\")\n\n            # query the item\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT product_english_name, element.symbol FROM recipe\n                JOIN element ON recipe.product_english_name = element.english_name\n                WHERE\n                    material0 = %s AND\n                    material1 = %s AND\n                    material2 = %s AND\n                    material3 = %s AND\n                    material4 = %s AND\n                    material5 = %s AND\n                    material6 = %s AND\n                    material7 = %s\n                LIMIT 1\n                \"\"\",\n                materials,\n            )\n\n            # ignore the possibility of multiple results\n            if len(row := await cnx.cursor.fetchall()) == 0:\n                return None\n            english_name, symbol = row[0]\n\n        # unlock the item\n        await self.unlock_item(team_id, english_name)\n\n        return english_name, symbol\n\n    async def get_inventory(self, team_id: int):\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT element.english_name, symbol\n                FROM element\n                JOIN team_element_unlocked ON element.english_name = team_element_unlocked.english_name\n                WHERE team_id = %s\n                \"\"\",\n                (team_id,),\n            )\n\n            return await cnx.cursor.fetchall()\n\n    async def check_recipe(self, recipe: Bounty.Recipe):\n        async with DBConnection() as cnx:\n\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT COUNT(*) FROM recipe\n                WHERE\n                    product_english_name = %s AND\n                    material0 = %s AND\n                    material1 = %s AND\n                    material2 = %s AND\n                    material3 = %s AND\n                    material4 = %s AND\n                    material5 = %s AND\n                    material6 = %s AND\n                    material7 = %s\n                \"\"\",\n                (recipe.product, *recipe.sorted_materials),\n            )\n\n            # ignore the possibility of multiple results\n            if len(row := await cnx.cursor.fetchall()) > 0:\n                return row[0][0] > 0\n\n            return False\n\n    async def get_recipe(self, team_id: int, english_name: str):\n        async with DBConnection() as cnx:\n\n            # check if all materials are unlocked by the team\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT 1 FROM team_element_unlocked\n                WHERE team_id = %s AND english_name = %s\n                LIMIT 1\n                \"\"\",\n                (team_id, english_name),\n            )\n\n            # check if the number of unlocked materials is equal to the number of unique materials\n            if len(row := await cnx.cursor.fetchall()) == 0 or row[0][0] != 1:\n                raise ValueError(\"Element not unlocked\")\n\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT id, product_english_name, \n                material0, material1,\n                material2, material3,\n                material4, material5,\n                material6, material7  FROM recipe\n                WHERE\n                    product_english_name like \"%s\"\n                \"\"\"\n                % english_name\n            )\n\n            return await cnx.cursor.fetchall()\n\n    async def get_bounty(\n        self, team_id: int, round_id: int | None = None\n    ) -> tuple[str, tuple[int, int], dict[int, int]] | None:\n        \"\"\"\n        Return:\n        - target_product: str\n        - (length, uploaded_round_id): tuple[int, int] # the information of the bounty set by the team\n        - {team_id: length}: dict[int, tuple[int, int]] # the information of the bounties submitted by other teams\n        \"\"\"\n        async with DBConnection() as cnx:\n            if round_id is None:\n                round_id = await self.get_current_round()\n\n            # get the end time of the round to filter bounties\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT end_at FROM round WHERE round_id = %s\n                \"\"\",\n                (round_id,),\n            )\n            if (\n                len(row := await cnx.cursor.fetchall()) == 0\n                or row[0] is None\n                or row[0][0] is None\n            ):\n                round_end_at = datetime(2050, 1, 1)  # 50 years later\n            else:\n                round_end_at = row[0][0]\n\n            # get the target product and length of the bounty\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT target_product, length, created_at\n                FROM bounty\n                WHERE team_id = %s AND is_submitted = FALSE AND created_at <= %s\n                ORDER BY created_at DESC\n                LIMIT 1\n                \"\"\",\n                (team_id, round_end_at),\n            )\n\n            if len(row := await cnx.cursor.fetchall()) == 0:\n                return None\n            target_product, length, set_bounty_created_at = row[0]\n            if target_product is None:\n                return None\n\n            # get the round_id when the bounty was set\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT round_id\n                FROM round\n                WHERE end_at >= %s\n                ORDER BY round_id ASC\n                LIMIT 1\n                \"\"\",\n                (set_bounty_created_at,),\n            )\n            if len(row := await cnx.cursor.fetchall()) == 0:\n                set_bounty_round_id = round_id  # current round\n            else:\n                set_bounty_round_id = row[0][0]\n\n            # get the submitted length of every other team\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT team_id, length\n                FROM (\n                    SELECT team_id, length,\n                        ROW_NUMBER() OVER (PARTITION BY team_id ORDER BY length ASC) AS rn\n                    FROM bounty\n                    WHERE target_product = %s AND team_id != %s AND length < %s AND created_at <= %s\n                ) AS ranked\n                WHERE rn = 1\n                \"\"\",\n                (target_product, team_id, length, round_end_at),\n            )\n\n            result = await cnx.cursor.fetchall()\n            return (\n                target_product,\n                (length, set_bounty_round_id),\n                {team_id_: length_ for team_id_, length_ in result},\n            )\n\n    async def insert_bounty(self, bounty: Bounty, is_submitted: bool = False):\n        team_id = await bounty.team_id()\n        target_product = bounty.target_product\n        length = bounty.length\n        bounty_body = bounty.model_dump_json()\n\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                INSERT INTO bounty (team_id, target_product, length, bounty_body, is_submitted)\n                VALUES (%s, %s, %s, %s, %s)\n                \"\"\",\n                (team_id, target_product, length, bounty_body, is_submitted),\n            )\n\n    async def clear_bounty(self, team_id: int):\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                INSERT INTO bounty (team_id, target_product, length, bounty_body, is_submitted)\n                VALUES (%s, NULL, 0, '{}', FALSE)\n                \"\"\",\n                (team_id,),\n            )\n\n    async def get_my_bounty_history(self, team_id: int):\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT target_product, length, bounty_body, created_at, is_submitted\n                FROM bounty\n                WHERE team_id = %s\n                ORDER BY created_at ASC\n                \"\"\",\n                (team_id,),\n            )\n\n            return await cnx.cursor.fetchall()\n\n    async def get_current_round(self) -> int | None:\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT MAX(round_id) FROM round\n                \"\"\"\n            )\n\n            if len(row := await cnx.cursor.fetchall()) > 0:\n                return row[0][0]\n\n            return None\n\n    async def get_round_info(self, round_id: int):\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT round_id, end_at, round_rank FROM round WHERE round_id = %s\n                \"\"\",\n                (round_id,),\n            )\n\n            if len(row := await cnx.cursor.fetchall()) == 0:\n                return None\n\n            round_id, end_at, round_rank = row[0]\n            return {\n                \"round_id\": round_id,\n                \"end_at\": end_at,\n                \"round_rank\": round_rank,\n            }\n\n    async def check_round_exist(self, round_id: int) -> bool:\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT 1 FROM round WHERE round_id = %s\n                \"\"\",\n                (round_id,),\n            )\n\n            return len(await cnx.cursor.fetchall()) > 0\n\n    async def insert_round_and_set_prev_round_end(self, round_id: int | None = None):\n        async with DBConnection() as cnx:\n            # make sure the operation is atomic\n            await cnx.cursor.execute(\"START TRANSACTION\")\n\n            # if the round is the first round of the day, ignore\n            # otherwise, end it\n            prev_round_id = await self.get_current_round()\n            if round_id is None:\n                round_id = prev_round_id + 1\n            if not (\n                round_id in config[\"scoreboard\"][\"start_round\"] or prev_round_id is None\n            ):\n                await cnx.cursor.execute(\n                    \"\"\"\n                    UPDATE round SET end_at = %s WHERE round_id = %s\n                    \"\"\",\n                    (datetime.now(), prev_round_id),\n                )\n\n            await cnx.cursor.execute(\n                \"\"\"\n                INSERT IGNORE INTO round (round_id) VALUES (%s)\n                \"\"\",\n                (round_id,),\n            )\n\n            await cnx.cursor.execute(\"COMMIT\")\n\n    async def set_rank(self, round_id: int, rank_str: str):\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                UPDATE round SET round_rank = %s WHERE round_id = %s\n                \"\"\",\n                (rank_str, round_id),\n            )\n\n    async def get_rank(self, round_id: int) -> str | None:\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT round_rank FROM round WHERE round_id = %s\n                \"\"\",\n                (round_id,),\n            )\n\n            if len(row := await cnx.cursor.fetchall()) == 0 or row[0][0] is None:\n                return None\n\n            return row[0][0]\n\n    async def get_bounty_for_calculating_score(self, round_id: int) -> dict | None:\n        \"\"\"\n        Return a dictionary where key is team_id and value is None or the returned value of get_bounty.\n        If the round isn't finished yet, return None.\n        \"\"\"\n        async with DBConnection() as cnx:\n            # get the end time of the round\n            await cnx.cursor.execute(\n                \"\"\"\n                SELECT end_at FROM round WHERE round_id = %s\n                \"\"\",\n                (round_id,),\n            )\n            if len(row := await cnx.cursor.fetchall()) == 0 or row[0][0] is None:\n                return None\n\n            # make sure the calculating is atomic\n            await cnx.cursor.execute(\"START TRANSACTION\")\n\n            ret = {\n                team[\"team_id\"]: await self.get_bounty(team[\"team_id\"], round_id)\n                for team in config[\"teams\"]\n            }\n\n            await cnx.cursor.execute(\"COMMIT\")\n\n            return ret\n\n    async def debug(self):\n        async with DBConnection() as cnx:\n            from pprint import pprint\n\n            await cnx.cursor.execute(\"SELECT * FROM element\")\n            pprint(await cnx.cursor.fetchall())\n\n            await cnx.cursor.execute(\"SELECT * FROM recipe\")\n            pprint(await cnx.cursor.fetchall())\n\n            await cnx.cursor.execute(\"SELECT * FROM team_element_unlocked\")\n            pprint(await cnx.cursor.fetchall())\n\n            await cnx.cursor.execute(\"SELECT * FROM bounty\")\n            pprint(await cnx.cursor.fetchall())\n\n    async def debug_clear_bounty(self):\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\"DELETE FROM bounty\")\n            await cnx.cursor.execute(\"ALTER TABLE bounty AUTO_INCREMENT = 1\")\n\n    async def debug_clear_round(self):\n        # delete all rounds but keep round_id = 0\n        async with DBConnection() as cnx:\n            await cnx.cursor.execute(\"DELETE FROM round WHERE round_id > 0\")\n            await cnx.cursor.execute(\n                \"UPDATE round SET end_at = NULL, round_rank = NULL WHERE round_id = 0\"\n            )\n\n    async def debug_clear_recipe(self):\n        async with DBConnection() as cnx:\n            await self.debug_clear_bounty()\n\n            await cnx.cursor.execute(\"DELETE FROM recipe\")\n            await cnx.cursor.execute(\"ALTER TABLE recipe AUTO_INCREMENT = 1\")\n\n            await cnx.cursor.execute(\"DELETE FROM team_element_unlocked\")\n            await cnx.cursor.execute(\n                \"ALTER TABLE team_element_unlocked AUTO_INCREMENT = 1\"\n            )\n\n            await self.create_tables()\n\n\ndb = DB()\n",
    "__init__.py": "",
    "config.py": "import sys\n\ntry:\n    import tomllib as toml\nexcept ImportError:\n    import tomli as toml\n\ntry:\n    with open('config.toml', 'rb') as f:\n        config = toml.load(f)\nexcept FileNotFoundError:\n    print('config.toml not found, maybe run `cp config.toml.example config.toml`', file=sys.stderr)\n    sys.exit(1)\n",
    "model.py": "from pydantic import BaseModel\n\nfrom .team import token2team_id\n\n\nclass Query(BaseModel):\n    team_token: str\n    material0: str\n    material1: str\n    material2: str\n    material3: str\n    material4: str\n    material5: str\n    material6: str\n    material7: str\n\n    async def team_id(self) -> int | None:\n        return await token2team_id(self.team_token)\n\n    @property\n    def sorted_materials(self) -> tuple[str, str, str, str, str, str, str, str]:\n        return tuple(sorted([\n            self.material0,\n            self.material1,\n            self.material2,\n            self.material3,\n            self.material4,\n            self.material5,\n            self.material6,\n            self.material7,\n        ]))\n\n\nclass Bounty(BaseModel):\n    class Recipe(BaseModel):\n        product: str\n        materials: tuple[str, str, str, str, str, str, str, str]\n\n        @property\n        def sorted_materials(self) -> tuple[str, str, str, str, str, str, str, str]:\n            return tuple(sorted(self.materials))\n\n    team_token: str\n    target_product: str\n    recipes: list[Recipe]\n\n    async def team_id(self) -> int | None:\n        return await token2team_id(self.team_token)\n\n    @property\n    def length(self) -> int:\n        return len(self.recipes)\n\n    async def validate(self, initial_items, check_recipe):\n        if await self.team_id() is None:\n            raise ValueError('invalid team token')\n\n        # check if recipes is not empty\n        if len(self.recipes) == 0:\n            raise ValueError('empty recipes')\n\n        # check if all products are unique\n        products = set()\n        for recipe in self.recipes:\n            if recipe.product in products:\n                raise ValueError('duplicate product: ' + recipe.product)\n            products.add(recipe.product)\n\n        # check if the last recipe produces the target product\n        if self.recipes[-1].product != self.target_product:\n            raise ValueError('target product mismatch')\n\n        # emulate the crafting process\n        discovered_items = set([item['english_name'] for item in initial_items])\n        used_items = discovered_items.copy()\n        for recipe in self.recipes:\n            # check if all materials are in discovered_items\n            if not all(material in discovered_items for material in recipe.materials):\n                raise ValueError('missing material: ' + '|'.join(set(recipe.materials) - discovered_items))\n\n            # check if the recipe is valid\n            if not await check_recipe(recipe):\n                raise ValueError('invalid recipe: ' + recipe.product + ' <- ' + '|'.join(recipe.materials))\n\n            discovered_items.add(recipe.product)\n            for material in recipe.materials:\n                used_items.add(material)\n\n        # check if there is any unused material\n        if len(used_items) + 1 != len(discovered_items):\n            raise ValueError('unused material: ' + '|'.join(discovered_items - used_items - {self.target_product}))\n",
    "round.py": "import asyncio\nfrom datetime import datetime\nimport math\nimport json\n\nfrom fastapi import FastAPI\n\nfrom .db import DB\nfrom .config import config\n\n\nclass RoundManager:\n    def __init__(self, polling_interval=1):\n        self.db = None\n        self.polling_interval = polling_interval\n\n    async def __aenter__(self):\n        try:\n            self.db = DB()\n            # await self.db.init()\n            return self\n        except ConnectionRefusedError as e:\n            raise ConnectionRefusedError(\n                f\"Cannot connect to database (maybe db not ready yet?): {e}\"\n            )\n\n    async def __aexit__(self, exc_type, exc, tb):\n        return\n\n    async def handler_job_KoHInit(self, round_id: int):\n        # a round starts when the KoHInit job of next round is received\n        # that is, the last round of every day should be end by manually sending an excessive KoHInit job\n\n        prev_round_id = await self.db.get_current_round()\n\n        await self.db.insert_round_and_set_prev_round_end(round_id)\n\n        if prev_round_id is not None:\n            await self.calculate_round_rank(prev_round_id)\n\n    async def calculate_round_rank(self, round_id: int):\n        bounty = await self.db.get_bounty_for_calculating_score(round_id)\n        if bounty is None:\n            raise ValueError(\"bounty is None, maybe the round is not ended yet\")\n\n        # calculate every team's score\n        score = {team[\"team_id\"]: 0 for team in config[\"teams\"]}\n        for team_id in score.keys():\n            if team_id not in bounty or bounty[team_id] is None:\n                continue\n\n            # calculate score of setting bounty\n            _, (set_bounty_length, set_bounty_round_id), other_team = bounty[team_id]\n            threshold = config[\"scoreboard\"][\"set_bounty_round_threshold\"]\n            score[team_id] += int(\n                min(round_id - set_bounty_round_id, threshold)\n                / threshold\n                * math.sqrt(set_bounty_length)\n            )\n\n            # calculate score of other team submitting the bounty\n            for team_id_, length_ in other_team.items():\n                score[team_id_] += set_bounty_length - length_\n\n        # generate rank like [{team:1,rank:1},{team:2,rank:2},{team:4,rank:2},{team:5,rank:4}]\n        sorted_score = sorted(score.items(), key=lambda x: x[1], reverse=True)\n        rank = []\n        r, prev_score = 1, math.inf\n        for team_id, _ in sorted_score:\n            if score[team_id] != prev_score:\n                r = len(rank) + 1\n                prev_score = score[team_id]\n            rank.append({\"team\": team_id, \"rank\": r})\n\n        # store rank to db (it will be sent on KoHScore job)\n        await self.db.set_rank(round_id, json.dumps(rank))\n\n    async def handler_job_KoHScore(self, round_id: int):\n        return await self.db.get_rank(round_id)\n\n\napp = FastAPI()\n\n\n@app.get(\"/kohinit\")\nasync def on_event_kohinit(round_id: int):\n    async with RoundManager() as rm:\n        await rm.handler_job_KoHInit(round_id)\n\n\n@app.get(\"/kohscore\")\nasync def on_event_kohscore(round_id) -> str | None:\n    async with RoundManager() as rm:\n        # workaround: for testing\n        if not await rm.db.check_round_exist(round_id):\n            return \"workaround: for testing\"\n\n        return await rm.handler_job_KoHScore(round_id)\n",
    "craft.py": "from fastapi import APIRouter\nimport httpx\n\nfrom ..db import db\nfrom ..config import config\nfrom ..model import Query\nfrom ..ratelimit import RateLimitMiddleware\n\nfrom koh_infinite_craft.client import crafting, get_logograph\n\n\nrouter = APIRouter(\n    prefix=\"/craft\",\n    tags=[\"craft\"],\n)\n\n\n@router.post(\"/\")\n@RateLimitMiddleware.limit(config[\"rate_limit\"][\"craft\"])\nasync def craft(query: Query):\n    \"\"\"\n    `material*` should contain the `english_name` of the materials.\n    \"\"\"\n    if await query.team_id() is None:\n        return {\"error\": \"invalid team token\"}\n\n    try:\n        result = await db.craft(query)\n        if result is not None and len(result) == 2:\n            return {\"english_name\": result[0], \"symbol\": result[1]}\n    except ValueError as e:\n        return {\"error\": str(e)}\n    except IndexError as e:\n        print(e, result)\n        return {\"error\": str(e)}\n\n    try:\n        # TODO: fix race condition\n        if config[\"backend_llm\"][\"enabled\"]:\n            api_key = config[\"backend_llm\"][\"novita_key\"]\n            element_english_name = await crafting(query.sorted_materials, api_key)\n            if element_english_name is None:\n                return {\"error\": \"these elements can't be combined\"}\n            element_symbol = await db.element_exist(element_english_name)\n            if element_symbol is None:\n                element_symbol = await get_logograph(element_english_name, api_key)\n            data = {\n                \"english_name\": element_english_name,\n                \"symbol\": element_symbol,\n            }\n\n        else:\n            tmp = \"\".join(query.sorted_materials)[:10]\n            data = {\n                \"english_name\": tmp,\n                \"symbol\": f\"\u5143\u7d20_{tmp}\",\n            }\n\n        await db.insert_item(\n            data[\"english_name\"], data[\"symbol\"], query.sorted_materials, await query.team_id()\n        )\n        return data\n\n    except Exception as e:\n        return {\"error\": str(e)}\n",
    "bounty.py": "from fastapi import APIRouter\n\nfrom ..db import db\nfrom ..model import Bounty\nfrom ..config import config\nfrom ..ratelimit import RateLimitMiddleware\nfrom ..team import token2team_id\n\n\nrouter = APIRouter(\n    prefix='/bounty',\n    tags=['bounty'],\n)\n\n\n@router.post('/set')\nasync def set_bounty(bounty: Bounty):\n    try:\n        await bounty.validate(config['initial_items'], db.check_recipe)\n    except ValueError as e:\n        return {'error': str(e)}\n\n    await db.insert_bounty(bounty, is_submitted=False)\n    return {'success': True}\n\n\n@router.post('/clear')\nasync def clear_bounty(team_token: str):\n    if (team_id := await token2team_id(team_token)) is None:\n        return {'error': 'invalid team token'}\n\n    await db.clear_bounty(team_id)\n    return {'success': True}\n\n\n@router.post('/submit')\nasync def submit_bounty(target_team_id: int, bounty: Bounty):\n    if await bounty.team_id() == target_team_id:\n        return {'error': 'self submission'}\n\n    # check if bounty exists\n    if (tmp := await db.get_bounty(target_team_id)) is None:\n        return {'error': 'bounty not found'}\n\n    target_product, (length, _), _ = tmp\n    if bounty.target_product != target_product:\n        return {'error': 'target product mismatch'}\n    if bounty.length >= length:\n        return {'error': 'useless submission'}\n\n    try:\n        await bounty.validate(config['initial_items'], db.check_recipe)\n    except ValueError as e:\n        return {'error': str(e)}\n\n    await db.insert_bounty(bounty, is_submitted=True)\n    return {'success': True}\n\n\n@router.post('/get')\n@RateLimitMiddleware.limit(config['rate_limit']['get_bounty'])\nasync def get_bounty(target_team_id: int):\n    if (bounty := await db.get_bounty(target_team_id)) is None:\n        return {'error': 'bounty not found'}\n\n    target_product, (length, uploaded_round_id), submitted = bounty\n    return {\n        'target_product': target_product,\n        'uploaded_round_id': uploaded_round_id,\n        'length': length,\n        'submitted': submitted,\n    }\n\n\n@router.post('/my_history')\n@RateLimitMiddleware.limit(config['rate_limit']['get_my_bounty_history'])\nasync def get_my_bounty(team_token: str):\n    if (team_id := await token2team_id(team_token)) is None:\n        return {'error': 'invalid team token'}\n\n    return await db.get_my_bounty_history(team_id)\n"
  }
}